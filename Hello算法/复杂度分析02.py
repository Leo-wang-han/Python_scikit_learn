"""
2.1
时间效率;算法运行时间的长短
空间效率：算法占用内存空间的大小
"""

"""
2.2.1
迭代：是一种重复执行某个任务的控制结构。
在迭代中，程序会在满足一定条件下重复执行某段代码，知道这个条件不在满足；
for循环、while循环、嵌套循环

2.2.2
递归：是一种算法策略，通过函数调用自身来解决问题。
两个阶段：
1.递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到"终止条件"；
2.归：触发“终止条件”，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果；
三要素：
1.终止条件：决定什么时候由“递”转“归”；
2.递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数；
3.返回结果：对应“归”，将当前递归层级的结果返回至上一层；
"""

"""
2.3时间复杂度：算法运行时间随着数据量变大时的增长趋势
2.3.1推算方法：
1.统计操作数量：忽略T(n)中的常数项，省略所有系数，循环嵌套使用乘法
2.判断渐近上界：时间复杂度由T(n)中的最高阶的项来决定

2.3.2常见类型
最差时间复杂度
O(1)<O(logn)<O(n)<O(nlogn)<O(n*2)<O(2**n)<O(n!)
"""

"""
2.4空间复杂度：衡量算法占用内存空间随着数据量变大时的增长趋势
2.4.1推算方法
空间复杂度=暂存空间（暂存数据+栈帧空间+指令空间）+ 输出空间
2.4.2常见类型
最差空间复杂度
O(1)<O(logn)<O(n)<O(n*2)<O(2**n)
"""
# 递归
def recur(n):
    if n==1:    # 终止条件
        return 1
    res = n + recur(n-1)    # 递：递归调用
    return res  # 归：返回结果

# 尾递归
def tail_recur(n, res):
    if n==0:    # 终止条件
        return  res
    res = tail_recur(n-1, n+res)    # 递：递归调用
    return res    # 归：返回结果
result1 = tail_recur(3,0)
print(result1)

# 递归树---斐波那契数列
def fib(n):
    if n==1 or n==2:
        return n-1
    res = fib(n-1) + fib(n-2)
    return res
result2 = fib(3)
print(result2)








